import os
from guess_language import guess_language

from PIL import Image, ImageEnhance
import numpy as np
import pytesseract
import cv2

from scipy.ndimage.filters import rank_filter
from scipy.ndimage import interpolation as inter
from skimage.transform import hough_line, hough_line_peaks
from skimage.feature import canny
from skimage.transform import rotate

info_retain_threshold = 0.005

pytesseract.pytesseract.tesseract_cmd = 'C:/Program Files (x86)/Tesseract-OCR/tesseract'

class ImageTextExtractor:
    def __init__(self,sigma=3.0,num_peaks=20,r_angle=0):
        try:
            self.sigma = sigma
            self.num_peaks = num_peaks
            self.r_angle = r_angle
            self.piby4 = np.pi / 4
        except Exception as e:
            # logger.error("Error while initialising ImageTextExtractor : "+str(e))
            raise Exception("Error while initialising ImageTextExtractor : "+str(e))

    def downscale_image(self, im, max_dim=2048):
        """Shrink im until its longest dimension is <= max_dim.
        Returns new_image, scale (where scale <= 1).
        """
        try:
            width, height = im.size
            if max(width, height) <= max_dim:
                return 1.0, im

            scale = 1.0 * max_dim / max(width, height)
            new_im = im.resize((int(width * scale), int(height * scale)), Image.ANTIALIAS)
            return scale, new_im
        except Exception as e:
            # logger.error("Error while downscaling image : "+str(e))
            return 1.0, im
            # raise Exception("Error while downscaling image : "+str(e))

    def find_border_components(self, contours, ary):
        try:
            borders = []
            area = ary.shape[0] * ary.shape[1]
            for i, c in enumerate(contours):
                x, y, w, h = cv2.boundingRect(c)
                if w * h > 0.5 * area:
                    borders.append((i, x, y, x + w - 1, y + h - 1))
            return borders
        except Exception as e:
            # logger.error("Error while finding border components of an image : "+str(e))
            return []
            # raise Exception("Error while finding border components of an image : "+str(e))

    def angle_from_right(self, deg):
        try:
            return min(deg % 90, 90 - (deg % 90))
        except Exception as e:
            # logger.error("Error while finding angle of image from right : "+str(e))
            return deg
            # raise Exception("Error while finding angle of image from right : "+str(e))

    def remove_border(self, contour, ary):
        """Remove everything outside a border contour."""
        # Use a rotated rectangle (should be a good approximation of a border).
        # If it's far from a right angle, it's probably two sides of a border and
        # we should use the bounding box instead.
        try:
            c_im = np.zeros(ary.shape)
            r = cv2.minAreaRect(contour)
            degs = r[2]
            if self.angle_from_right(degs) <= 10.0:
                box = cv2.boxPoints(r)
                box = np.int0(box)
                cv2.drawContours(c_im, [box], 0, 255, -1)
                cv2.drawContours(c_im, [box], 0, 0, 4)
            else:
                x1, y1, x2, y2 = cv2.boundingRect(contour)
                cv2.rectangle(c_im, (x1, y1), (x2, y2), 255, -1)
                cv2.rectangle(c_im, (x1, y1), (x2, y2), 0, 4)

            return np.minimum(c_im, ary)
        except Exception as e:
            # logger.error("Error while removing border components of an image : "+str(e))
            return ary
            # raise Exception("Error while removing border components of an image : "+str(e))

    def dilate(self, ary, N, iterations):
        """Dilate using an NxN '+' sign shape. ary is np.uint8."""
        try:
            kernel = np.zeros((N, N), dtype=np.uint8)
            kernel[(N - 1) // 2, :] = 1
            dilated_image = cv2.dilate(ary / 255, kernel, iterations=iterations)

            kernel = np.zeros((N, N), dtype=np.uint8)
            kernel[:, (N - 1) // 2] = 1
            dilated_image = cv2.dilate(dilated_image, kernel, iterations=iterations)
            return dilated_image
        except Exception as e:
            # logger.error("Error while dilating image : "+str(e))
            return ary
            # raise Exception("Error while dilating image : "+str(e))

    def find_components(self, edges, max_components=32):
        """Dilate the image until there are just a few connected components.
        Returns contours for these components."""
        # Perform increasingly aggressive dilation until there are just a few
        # connected components.
        try:
            total = np.sum(edges) / 255
            area = edges.shape[0] * edges.shape[1]
            if (total / area) < 0.005:
                max_components = 16
            dilation = 5
            count = max_components + dilation
            n = 1
            while count > max_components:
                n += 1
                dilated_image = self.dilate(edges, N=3, iterations=n)
                dilated_image = np.uint8(dilated_image)
                _, contours, hierarchy = cv2.findContours(dilated_image, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
                count = len(contours)
            return contours
        except Exception as e:
            # logger.error("Error while finding components (contours) of image : " + str(e))
            return []
            # raise Exception("Error while finding components (contours) of image : "+str(e))

    def props_for_contours(self, contours, ary):
        """Calculate bounding box & the number of set pixels for each contour."""
        try:
            c_info = []
            for c in contours:
                x, y, w, h = cv2.boundingRect(c)
                c_im = np.zeros(ary.shape)
                cv2.drawContours(c_im, [c], 0, 255, -1)
                c_info.append({
                    "x1": x,
                    "y1": y,
                    "x2": x + w - 1,
                    "y2": y + h - 1,
                    "sum": np.sum(ary * (c_im > 0)) / 255
                })
            return c_info
        except Exception as e:
            # logger.error("Error while props of contours of image : "+str(e))
            return []
            # raise Exception("Error while props of contours of image : "+str(e))

    def crop_area(self, crop):
        try:
            return max(0, crop["x2"] - crop["x1"]) * max(0, crop["y2"] - crop["y1"])
        except Exception as e:
            # logger.error("Error while finding area of crop",crop," : "+str(e))
            return 0
            # raise Exception("Error while finding area of crop",crop," : "+str(e))

    def find_optimal_subsets(self, contours, edges):
        """Find a crop which strikes a good balance of coverage/compactness.
                Returns an (x1, y1, x2, y2) tuple.
                """
        try:
            c_info = self.props_for_contours(contours, edges)
            total = np.sum(edges) / 255
            area = edges.shape[0] * edges.shape[1]
            new_c_info = []
            for crop in c_info:
                recall = 1.0 * crop["sum"] / total
                prec = 1 - 1.0 * self.crop_area(crop) / area
                f1 = 2 * (prec * recall / (prec + recall))
                if f1>info_retain_threshold:
                    new_c_info.append(crop)
            c_info = new_c_info
            c_info.sort(key=lambda x: x["x1"])
            c_info.sort(key=lambda x: x["y1"])

            new_c_info = []
            for c in c_info:
                new_crop = c
                if self.check_if_exists_in_array(c, new_c_info):
                    continue
                else:
                    new_c_info.append(new_crop)
            new_c_info = [(c["x1"],c["y1"],c["x2"],c["y2"]) for c in new_c_info]
            return new_c_info
        except Exception as e:
            # logger.error("Error while finding optimal subsets of image : "+str(e))
            return []
            # raise Exception("Error while finding optimal subsets of image : "+str(e))

    def check_if_exists_in_array(self,incoming_crop,crops_list):
        try:
            if incoming_crop in crops_list:
                return True
            does_exist = False
            for crop in crops_list:
                if incoming_crop["x1"]>=crop["x1"] and incoming_crop["x2"]<=crop["x2"]:
                    if incoming_crop["y1"] >= crop["y1"] and incoming_crop["y2"] <= crop["y2"]:
                        does_exist = True
                        break
            return does_exist
        except Exception as e:
            # logger.error("Error while checking duplicacy of subsets of image : "+str(e))
            return False
            # raise Exception("Error while checking duplicacy of subsets of image : "+str(e))

    def process_image(self, byte_image):

        try:
            # orig_im = Image.open(io.BytesIO(byte_image))
            orig_im = byte_image
            greyScale_image = orig_im.convert('L')
            scale, im = self.downscale_image(greyScale_image)

            edges = cv2.Canny(np.asarray(im), 100, 200)

            _, contours, hierarchy = cv2.findContours(edges, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
            borders = self.find_border_components(contours, edges)
            borders.sort(
                key=lambda i_x1_y1_x2_y2: (i_x1_y1_x2_y2[3] - i_x1_y1_x2_y2[1]) * (i_x1_y1_x2_y2[4] - i_x1_y1_x2_y2[2]))

            border_contour = None
            if len(borders):
                border_contour = contours[borders[0][0]]
                edges = self.remove_border(border_contour, edges)

            edges = 255 * (edges > 0).astype(np.uint8)

            # Remove ~1px borders using a rank filter.
            maxed_rows = rank_filter(edges, -4, size=(1, 20))
            maxed_cols = rank_filter(edges, -4, size=(20, 1))
            debordered = np.minimum(np.minimum(edges, maxed_rows), maxed_cols)
            edges = debordered

            contours = self.find_components(edges)
            if len(contours) == 0:
                # logger.warning("No Text Found")
                return ""

            crops = self.find_optimal_subsets(contours, edges)
            text_segments = []
            for i, crop in enumerate(crops):
                new_crop = [int(x / scale) for x in crop]
                text_im = greyScale_image.crop(new_crop)
                # text_im.save("segment_"+str(i)+".jpg")
                text_im.show()
                img_txt = pytesseract.image_to_string(text_im).strip()
                if len(img_txt) and img_txt not in text_segments:
                    text_segments.append(img_txt)
            return text_segments
        except Exception as e:
            # logger.error("Error while processing image : " + str(e))
            return ""
            # raise Exception("Error while processing image : " + str(e))



if __name__ == "__main__":
    obj = ImageTextExtractor()
    import time
  
    # response = requests.get(url=url)
    # byte_image = response.content
    # img = Image.open(io.BytesIO(content))
    img = Image.open("1_62162480.pdf.jpg")
    st_time = time.time()
    text_seg = obj.process_image(img)
    print("Time Taken =====>",time.time() - st_time)
    print(text_seg)
